; --------------------------------------------------------------------------------
; @Title: Startup Script for the Cortex-A8 on OMAP3530 BeagleBoard
; @Description:
;   Cortex-A8 on OMAP3530 beagle board startup.
;   Memory setup not fully tested.
;   The board has no trace port.
; @Keywords: Cortex-A8, TI
; @Author: STK
; @Board: BeagleBoard
; @Chip: OMAP3530
; @Copyright: (C) 1989-2019 Lauterbach GmbH, licensed for use with TRACE32(R) only
; --------------------------------------------------------------------------------
; $Id: start_cortex.cmm 15217 2019-11-04 16:17:15Z bschroefel $


; STK, 2009-04-22


; Basic setup
  SYStem.RESet
  SYStem.CPU OMAP3530
  SYStem.JtagClock RTCK
  SYStem.Up

  ; required for emulation device
  Register.Set NS 1

  GOSUB disable_watchdog
  GOSUB prcm_clocking_conf_IIa
  GOSUB setgpmcsdrc

; Laod demo application
  Data.LOAD.ELF ~~~~/demo_cortexa8.axf
  Register.Set PC main
  Register.Set R13 0x4020f000

; Release_IVA_reset

  ; Enable DSP-ss functional clock (set bit 0) CM_FCLKEN_IVA2*/
  Data.Set ASD:0x48004000 %Long 0yxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx1

  ; IVA clk is bypassed CORE clock/2 CM_CLKSEL1_PLL_IVA2*/
  Data.Set ASD:0x48004040 %Long (2<<19.)

  ; Enable IVA2 DPLL (low power mode bybass -> 5) CM_CLKEN_PLL_IVA2*/
  Data.Set ASD:0x48004004 %Long ((1<<4)|(5<<0))

  ; Release DSPMMU reset (clear bit 1) -> RM_RSTCTRL_IVA2 */
  Data.Set ASD:0x48306050 %Long 0yxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx0x

  ; Set DSP boot mode to WaitInDeadLoop -> CONTROL_IVA2_BOOTMODE */
	Data.Set ASD:0x48002404 %Long 2

	;Release DSP from reset (clear bit 0) -> RM_RSTCTRL_IVA2 */
	Data.Set ASD:0x48306050 %l 0yxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx0

; open some windows
  WinCLEAR
  WinPOS 0% 0% 100% 50%
  List.auto
  WinPOS 0% 50% 50% 50%
  Frame /Locals /Caller
  WinPOS 50% 50% 50% 50%
  Var.Watch
  Var.AddWatch ast; flags;


ENDDO


disable_watchdog:
(
  ; Enable Interface Clock
  Data.Set ASD:0x48004C10 %Long 0x20

  ; Enable functional clock
  Data.Set ASD:0x48004C00 %Long 0x20

  ; Check that module is IDLE
  WAIT (Data.Long(ASD:0x48004C20)&0x20)==0

  ; Disable watchdog timer
  Data.Set ASD:0x48314048 %LE %Long 0x0000AAAA;
  WAIT (Data.Long(ASD:0x48314034)&0x10)==0

  Data.Set ASD:0x48314048 %LE %Long 0x00005555;
  WAIT (Data.Long(ASD:0x48314034)&0x10)==0

  ; Check if the watchdog timer is running */
  IF (Data.Long(ASD:0x48314048)!=0x00005555)
  (
    ; Disable Watchdog 2
    ; Wait until reset complete */
    WAIT (Data.Long(ASD:0x48314014)&0x01)!=0

    ; Disable 32Khz watchdog timer */
    Data.Set ASD:0x48314048 %Long 0x0000AAAA

    WAIT (Data.Long(ASD:0x48314034)&0x10)==0

    ; Disable 32Khz watchdog timer
    Data.Set ASD:0x48314048 %Long 0x00005555

    WAIT (Data.Long(ASD:0x48314034)&0x10)==0
  )

  RETURN
)


prcm_clocking_conf_IIa:
(
  ; Set system clock to 19.2MHz (PRM_CLKSEL_REG)
  Data.Set ASD:0x48306D40 %LE %Long 0x2

  &val=Data.Long(ASD:0x48004D00)
  &val=&val&(~0x07)
  &val=&val|(5<<0)
  Data.Set ASD:0x48004D00 %LE %Long &val

  WHILE ((Data.Long(ASD:0x48004d20)&(0x1))==0x1)

  ; Program CM_CLKSEL_CORE_REG
  ; .................    L3             L4         FSHOSTUSB    GPT10    GPT11      SSI
  Data.Set ASD:0x48004A40 %LE %Long ((2<<0)|(2<<2)|(2<<4)|(0<<6)|(0<<7)|(3<<8))

  ; Program DPLL
  ; Multiplier = 242
  ; Divisor = 13
  ; CORE_DPLL_CLKOUT_DIV
  ; APLL clock source = 19.2MHz system clock
  ; 54MHz and 48MHz clocks are derived from APLL
  Data.Set ASD:0x48004D40 %LE %Long ((1<<27.)|(242.<<16.)|(13.<<8)|(0<<5)|(0<<3))

  ; Put DPLL into lock mode
  ; Set CORE DPLL FreqSel: 0.75-1MHz
  Data.Set ASD:0x48004d00 %LE %Long (data.long(d:0x48004D00)|(5<<4)|(7<<0))

  ; Wait for DPLL to be in lock mode
  WHILE ((Data.Long(ASD:0x48004d20)&(0x1))!=0x1)

  RETURN
)



setgpmcsdrc:
(
  ; issues software reset of SDRAM interface
  Data.Set ASD:0x6D000010 %le %long 0x0000000a
  REPEAT 0x100
  (
  wait 1.ms
  )

  ; remove reset
  Data.Set ASD:0x6D000010 %LE %long 0x00000008

  ; set up sram mux mode for external connection
  ; SDRCSharing
  ; Chip-level shared interface management
  ; Assumption is that both the 16Mx32 chips are connected to CS0 of SDRC.
  ; i.e 1GBit part 32Mx32 is connected to CS0 = 128 MB
                                      ; SDRCTriState: no Tris
                                      ; CS0MuxCfg: 000 (32-bit SDRAM on D31..0)
                                      ; CS1MuxCfg: 000 (32-bit SDRAM on D31..0)
  ;Data.Set sd:0x6D000070 %le %long 0x000000C5
  Data.Set ASD:0x6D000080 %LE %Long 0x01702019
  Data.Set ASD:0x6D0000B0 %LE %Long 0x01702019
  Data.Set ASD:0x6D000044 %LE %Long 0x00000100

  REPEAT 0x2
  (
    wait 1.ms
  )

  ;   ACTIMA
  Data.Set ASD:0x6D00009c %LE %Long 0x629DB485
  Data.Set ASD:0x6D0000C4 %LE %Long 0x629DB485

  ;   ACTIMB
  Data.Set ASD:0x6D0000A0 %LE %Long 0x00001012
  Data.Set ASD:0x6D0000C8 %LE %Long 0x00001012

  ;SDRC_RFR_CTRL_0
  Data.Set ASD:0x6D0000A4 %LE %Long 0x00005D01
  Data.Set ASD:0x6D0000D4 %LE %Long 0x00005D01

  ;Manual Command sequence
  Data.Set ASD:0x6D0000A8 %LE %Long 0x00000000
  Data.Set ASD:0x6D0000A8 %LE %Long 0x00000001
  Data.Set ASD:0x6D0000A8 %LE %Long 0x00000002
  Data.Set ASD:0x6D0000A8 %LE %Long 0x00000002

  Data.Set ASD:0x6D0000D8 %LE %Long 0x00000000
  Data.Set ASD:0x6D0000D8 %LE %Long 0x00000001
  Data.Set ASD:0x6D0000D8 %LE %Long 0x00000002
  Data.Set ASD:0x6D0000D8 %LE %Long 0x00000002

  ; CS0 SDRC Mode Register
  ; Burst length = 4 - DDR memory
  ; Serial mode = Serial
  ; CAS latency = 3
  Data.Set ASD:0x6D000084 %LE %Long 0x00000032
  Data.Set ASD:0x6D0000B4 %LE %Long 0x00000032

  ;Configure EMR_0 and EMR_1
  Data.Set ASD:0x6D00008C %LE %Long 0x00000020
  Data.Set ASD:0x6D0000BC %LE %Long 0x00000020

  ;  /* SDRC DLLA control register */
  ;  /* Enable DLL, Load counter with 115 (middle of range) */
  ;  /* Delay is 90 degrees */
  Data.Set ASD:0x6D000060 %LE %long 0x0000000a ;

  ; Wait for DLL lock time.
  REPEAT 0x10
  (
    WAIT 1.ms
  )

  RETURN
)
