; --------------------------------------------------------------------------------
; @Title: SMP-Demo script for AM5728 with Offchip-Trace (RAM, SMP, TPIU)
; @Description:
;   Loads the sieve demo application into RAM and sets up a demo debug
;   scenario.
;   Use this script to test the Offchip-Trace.
;   Prerequisites:
;     * required modifications on TMDXIDK5728 board to get all trace signals
;       (muxed with LCD) to J18:
;       replace R731 by 0 Ohms
;       close (0 Ohms) R711-R728 (EMU2-EMU19)
;       open (remove) R554-R555 (EMU0-EMU1)
;       open (remove) R607-R612 (EMU2, EMU5-EMU9)
;       open (remove) R615-R620 (EMU3, EMU10-EMU14)
;       open (remove) R623-R628 (EMU4, EMU15-EMU19)
;    * Connect Debug and Trace Probe to J18
;      e.g. Debug Cable, Mictor Preprocessor by converter LA-3818
; @Keywords: ARM, Cortex-A15, SMP
; @Author: PEG
; @Board: TMDXIDK5728
; @Chip: AM57*
; @Copyright: (C) 1989-2019 Lauterbach GmbH, licensed for use with TRACE32(R) only
; --------------------------------------------------------------------------------
; $Id: tmdxidk5728_sieve_offchip_trace_smp_sram.cmm 15217 2019-11-04 16:17:15Z bschroefel $


WinCLEAR

; --------------------------------------------------------------------------------
; initialize and start the debugger
RESet
SYStem.RESet
SYStem.CPU AM572X
SYStem.JtagClock CTCK 20MHz
SYStem.Option ResBreak OFF
CORE.ASSIGN 1. 2.
SYStem.Up

; --------------------------------------------------------------------------------
; load demo program (uses internal RAM only)
CORE.select 0.
Data.LOAD.Elf "~~~~/sieve_ram_arm_v7.elf"

; Set PC for all secondary cores
Register.Set T 0 /CORE 1.
Register.Set PC _start /CORE 1.

; --------------------------------------------------------------------------------
; start program execution
Go.direct main
WAIT !STATE.RUN()

IF Analyzer()
(
  ; optional - raise TRACECLK
  ; GOSUB InitTraceClk

  ; pad muxing for 16/(18-bit) trace port (EMU0 - EMU19)
  Data.Set AHB:0x4a003848 %Long 0x00090000 ; CTRL_CORE_PAD_EMU0 (EMU0)
  Data.Set AHB:0x4a00384c %Long 0x00090000 ; CTRL_CORE_PAD_EMU1 (EMU1)
  Data.Set AHB:0x4a0035e4 %Long 0x00090002 ; CTRL_CORE_PAD_VOUT1_D2 (EMU2)
  Data.Set AHB:0x4a003604 %Long 0x00090002 ; CTRL_CORE_PAD_VOUT1_D10(EMU3)
  Data.Set AHB:0x4a003624 %Long 0x00090002 ; CTRL_CORE_PAD_VOUT1_D18(EMU4)
  Data.Set AHB:0x4a0035e8 %Long 0x00090002 ; CTRL_CORE_PAD_VOUT1_D3 (EMU5)
  Data.Set AHB:0x4a0035ec %Long 0x00090002 ; CTRL_CORE_PAD_VOUT1_D4 (EMU6)
  Data.Set AHB:0x4a0035f0 %Long 0x00090002 ; CTRL_CORE_PAD_VOUT1_D5 (EMU7)
  Data.Set AHB:0x4a0035f4 %Long 0x00090002 ; CTRL_CORE_PAD_VOUT1_D6 (EMU8)
  Data.Set AHB:0x4a0035f8 %Long 0x00090002 ; CTRL_CORE_PAD_VOUT1_D7 (EMU9)
  Data.Set AHB:0x4a003608 %Long 0x00090002 ; CTRL_CORE_PAD_VOUT1_D11(EMU10)
  Data.Set AHB:0x4a00360c %Long 0x00090002 ; CTRL_CORE_PAD_VOUT1_D12(EMU11)
  Data.Set AHB:0x4a003610 %Long 0x00090002 ; CTRL_CORE_PAD_VOUT1_D13(EMU12)
  Data.Set AHB:0x4a003614 %Long 0x00090002 ; CTRL_CORE_PAD_VOUT1_D14(EMU13)
  Data.Set AHB:0x4a003618 %Long 0x00090002 ; CTRL_CORE_PAD_VOUT1_D15(EMU14)
  Data.Set AHB:0x4a003628 %Long 0x00090002 ; CTRL_CORE_PAD_VOUT1_D19(EMU15)
  Data.Set AHB:0x4a00362c %Long 0x00090002 ; CTRL_CORE_PAD_VOUT1_D20(EMU16)
  Data.Set AHB:0x4a003630 %Long 0x00090002 ; CTRL_CORE_PAD_VOUT1_D21(EMU17)
  Data.Set AHB:0x4a003634 %Long 0x00090002 ; CTRL_CORE_PAD_VOUT1_D22(EMU18)
  Data.Set AHB:0x4a003638 %Long 0x00090002 ; CTRL_CORE_PAD_VOUT1_D23(EMU19)

  ; configure Debug Resource Manager and select port size 16
  Trace.METHOD Analyzer
  TPIU.PortSize 16
  TPIU.PortMode Continuous
  ETM.Trace ON
  ETM.ON

  Trace.AutoFocus
)

; --------------------------------------------------------------------------------
; open some windows
WinCLEAR
Mode.Hll
WinPOS 0. 0.
List.auto
WinPOS 120. 0. 100. 8.
Frame.view
WinPOS 120. 14.
Var.Watch
Var.AddWatch %SpotLight ast flags
WinPOS 120. 25.
Trace.List
WinPOS 0. 32.
Var.DRAW %DEFault sinewave

ENDDO

InitTraceClk: ;()
(
  ; EMU_SYSCLK=38.4MHz
  ; DPLL_DEBUG M/N = 117 (=0x75) / 3
  ; DPLL_DEBUG FREQ = ~1.44GHz
  ; HS_DIV Factor TRACECLKIN = 4 => M6=3
  ; TRACECLKIN = ~360MHz
  ; TRACECLK = ~180MHz
  ; HS_DIV Factor DBG_CLK, STM_FUNC_CLK = 6 => M4=M5=5
  ; DBG_CLK = STM_FUNC_CLK = ~240MHz

  ; Set M4,M5 to maximum division value
  Data.Set DAP:0xD417180C %Long Data.Long(DAP:0xD417180C)|(0x1f<<21.)|(0x1f<<26.)
  ; Set M6 to maximum division value
  Data.Set DAP:0xD4171814 %Long Data.Long(DAP:0xD4171814)|(0x1f<<0)
  ; request HSDIV Update
  Data.Set DAP:0xD4171808 %Long 0x2
  ; enable M4, M5, M6 clock
  Data.Set DAP:0xD4171810 %Long Data.Long(DAP:0xD4171810)|(0x1<<23.)|(0x1<<18.)|(0x1<<16.)
  ; set PLL bypass
  Data.Set DAP:0xD4171810 %Long Data.Long(DAP:0xD4171810)|(0x1<<15.)
  ; request PLL relock
  Data.Set DAP:0xD4171808 %Long 0x1
  WAIT (Data.Long(DAP:0xD4171808)&0x1)==0x0
  ; Update PLL DIVM/DIVN = 117 / 3
  Data.Set DAP:0xD417180C %Long (Data.Long(DAP:0xD417180C)&~((0xfff<<9.)|(0xff<<1.)))|((116.<<9.)|(2.<<1.))
  ; request PLL relock
  Data.Set DAP:0xD4171808 %Long 0x1
  WAIT (Data.Long(DAP:0xD4171808)&0x1)==0x0
  ; clear PLL bypass
  Data.Set DAP:0xD4171810 %Long Data.Long(DAP:0xD4171810)|(0x1<<15.)
  ; request PLL relock
  Data.Set DAP:0xD4171808 %Long 0x1
  WAIT (Data.Long(DAP:0xD4171808)&0x1)==0x0
  ; clear PLL bypass
  Data.Set DAP:0xD4171810 %Long Data.Long(DAP:0xD4171810)&~(0x1<<15.)
  ; request PLL relock
  Data.Set DAP:0xD4171808 %Long 0x1
  WAIT (Data.Long(DAP:0xD4171808)&0x1)==0x0
  ; Set M6 to 3 - change this value to lower TraceFrequency
  Data.Set DAP:0xD4171814 %Long (Data.Long(DAP:0xD4171814)&~(0x1f<<0.))|(0x3<<0.)
  ; request HSDIV Update
  Data.Set DAP:0xD4171808 %Long 0x2
  ; set M4,M5 to 5
  Data.Set DAP:0xD417180C %Long (Data.Long(DAP:0xD417180C)&~((0x1f<<21.)|(0x1f<<26.)))|(5.<<21.)|(5.<<26.)
  ; request HSDIV Update
  Data.Set DAP:0xD4171808 %Long 0x2

  RETURN
)