; --------------------------------------------------------------------------------
; @Title: init script on SDRAM for Leopard TMS320DM365
; @Description:
;
;   This script initialize and configure PLL DDR and ARM
; 
;   SDRAM: 0x80002000    
;
; @Author: MSA
; @Board: Leopard
; @Chip: TMS320DM365
; @Keywords: ARM926EJ-S, sieve
; @Copyright: (C) 1989-2019 Lauterbach GmbH, licensed for use with TRACE32(R) only
; --------------------------------------------------------------------------------
; $Id: dm365-init.cmm 15217 2019-11-04 16:17:15Z bschroefel $


  LOCAL &SYSTEM_BASE
  LOCAL &VPSS_CLKCTL
  LOCAL &PERI_CLKCTL
  LOCAL &GPINT_GPEN
  LOCAL &GPTDAT_GPDIR

  &SYSTEM_BASE=0x01C40000
  &VPSS_CLKCTL=&SYSTEM_BASE+0x44
  &PERI_CLKCTL=&SYSTEM_BASE+0x48
  &GPINT_GPEN=0x01C21C08
  &GPTDAT_GPDIR=0x01C21C0C

  IF (Data.Long(SD:0x01C408E4)*0x3!=0x0)  //  Only initialize on cold boot (RSTYPE field)
  (
    PRINT "VPSS Sync Reset Fix"
    Data.Set &VPSS_CLKCTL %Long 0x80
    GOSUB psc_change_state  47. 0x1
    Data.Set &GPINT_GPEN %Long 0x00020000
    Data.Set &GPTDAT_GPDIR %Long 0x00020002
  )

  Data.Set &PERI_CLKCTL  %Long 0x243F0FF8      // Peripheral Clock control

  GOSUB Setup_Psc_All_On
  GOSUB Setup_PLL1            // Configure DDR
  GOSUB Setup_PLL2            // Configure ARM
  GOSUB Setup_DDR2            // Configure DDR2 controller

  SYStem.JtagClock 10.Mhz

  PRINT "Startup Complete."
  PRINT ""
  
  ENDDO


Setup_Psc_All_On:

  LOCAL &i
  &i=0x0

  PRINT "Setup Power Modules (All on)... "

  RePeaT 53.
  (

    IF &i!=41.
    (
      GOSUB psc_change_state &i 0x3
    )
    &i=&i+0x1
  )

  GOSUB psc_change_state 41. 0x3

  PRINT "[Done]" 

RETURN



psc_change_state:
  LOCAL &id 
  LOCAL &state

  ENTRY &id &state

  LOCAL &PSC_PTCMD
  LOCAL &PSC_PTSTAT
  LOCAL &mdstat
  LOCAL &mdctl

  &PSC_PTCMD=0x01c41120
  &PSC_PTSTAT=0x01c41128

  &mdstat=0x01c41800+(0x4*&id)
  &mdctl=0x01c41a00+(0x4*&id)

  IF (Data.Long(SD:&mdstat)&0x1F)==&state
    RETURN
  WAIT 10.ms

  Data.Set &mdctl %Long Data.Long(SD:&mdctl)&~0x1F
  Data.Set &mdctl %Long Data.Long(SD:&mdctl)|&state
  
  Data.Set &PSC_PTCMD %Long Data.Long(SD:&PSC_PTCMD)|0x1
  
  WAIT 10.ms

RETURN


Setup_PLL1:

  LOCAL &pll_ctl
  LOCAL &pll_secctl
  LOCAL &pll_pllm
  LOCAL &pll_prediv
  LOCAL &pll_cmd
  LOCAL &pll_stat
  LOCAL &pll_div1
  LOCAL &pll_div2
  LOCAL &pll_div3
  LOCAL &pll_postdiv
  LOCAL &pll_div4
  LOCAL &pll_div5
  LOCAL &pll_div6
  LOCAL &pll_div7
  LOCAL &pll_div8
  LOCAL &pll_div9
  LOCAL &regValue
  
  &pll_ctl=0x01c40900
  &pll_secctl=0x01c40908
  &pll_pllm=0x01c40910
  &pll_prediv=0x01c40914
  &pll_cmd=0x01c40938
  &pll_stat=0x01c4093c
  &pll_div1=0x01c40918
  &pll_div2=0x01c4091c
  &pll_div3=0x01c40920
  &pll_postdiv=0x01c40928
  &pll_div4=0x01c40960
  &pll_div5=0x01c40964
  &pll_div6=0x01c40968
  &pll_div7=0x01c4096C
  &pll_div8=0x01c40970
  &pll_div9=0x01c40974
  

  PRINT  "Setup PLL0... "

  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)&~0x0002        // Power up PLL
  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)|0x0010        // Put PLL in disable mode
  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)&~0x0010        // Take PLL out of disable mode
  
  
  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)&~0x0100;       // Onchip Oscillator
;  *pll_ctl |=0x0100;        // External Oscillator
  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)&~0x0020;       // Clear PLLENSRC
  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)&~0x0001;       // Set PLL in bypass
  WAIT 200.ms

  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)|0x0008;        // Assert PLL reset
  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)&~0x0008;       // Take PLL out of reset

  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)&~0x0010;       // Enable PLL
  WAIT 150.ms


;  /* PLLOUT=(OSCIN / prediv) * 2 * (pllm / postdiv)=(24/8) * 2 * (81/1)=486MHz */
  Data.Set &pll_pllm %Long 81.
  Data.Set &pll_prediv %Long 0x8007
  
  WAIT 100.ms

  Data.Set &pll_secctl %Long 0x00470000
  Data.Set &pll_secctl %Long 0x00460000
  Data.Set &pll_secctl %Long 0x00400000
  Data.Set &pll_secctl %Long 0x00410000
  Data.Set &pll_postdiv %Long 0x8000

  Data.Set &pll_div3 %Long 0x8001
  Data.Set &pll_div4 %Long 0x8003
  Data.Set &pll_div5 %Long 0x8001
  Data.Set &pll_div6 %Long 0x8011
  Data.Set &pll_div7 %Long 0x8000
  Data.Set &pll_div8 %Long 0x8004
  Data.Set &pll_div9 %Long 0x8001

  Data.Set &pll_cmd %Long Data.Long(sd:&pll_cmd)|0x0001

  WAIT 1.s

  Data.Set &pll_ctl %Long 0x1

  PRINT "[Done]"

RETURN

Setup_PLL2:

  LOCAL &pll_ctl
  LOCAL &pll_secctl
  LOCAL &pll_pllm
  LOCAL &pll_prediv
  LOCAL &pll_cmd
  LOCAL &pll_stat
  LOCAL &pll_div1
  LOCAL &pll_div2
  LOCAL &pll_div3
  LOCAL &pll_postdiv
  LOCAL &pll_div4
  LOCAL &pll_div5
  LOCAL &pll_bpdiv

  &pll_ctl= 0x01c40d00
  &pll_secctl= 0x01c40d08
  &pll_pllm= 0x01c40d10
  &pll_prediv= 0x01c40d14
  &pll_cmd= 0x01c40d38
  &pll_stat= 0x01c40d3c
  &pll_div1= 0x01c40d18
  &pll_div2= 0x01c40d1c
  &pll_div3= 0x01c40d20
  &pll_postdiv= 0x01c40d28
  &pll_div4= 0x01c40d60
  &pll_div5= 0x01c40d64
  &pll_bpdiv= 0x01c40d2c
 
  PRINT  "Setup PLL1... ";

  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)&~0x0002;        // Power up PLL
  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)|0x0010;        // Put PLL in disable mode
  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)&~0x0010;        // Take PLL out of disable mode

  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)&~0x0100;       // Onchip Oscillator
;  *pll_ctl |= 0x0100;        // External Oscillator
  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)&~0x0020;       // Clear PLLENSRC
  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)&~0x0001;       // Set PLL in bypass
  WAIT 150.ms

  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)|0x0008;        // Assert PLL reset
  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)&~0x0008;       // Take PLL out of reset

  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)&~0x0010;       // Enable PLL
  WAIT 150.ms          // Wait for PLL to stabilize

  Data.Set &pll_pllm %Long 99       // PLL out= (24/8) * 99 * 2 / 1= 594MHz
  Data.Set &pll_prediv %Long  0x8007;      // prediv= 8

  Data.Set &pll_postdiv %Long 0x8000;
  
  Data.Set &pll_secctl %Long 0x00470000;    // Assert TENABLE= 1, TENABLEDIV= 1, TINITZ= 1
  Data.Set &pll_secctl %Long 0x00460000;    // Assert TENABLE= 1, TENABLEDIV= 1, TINITZ= 0
  Data.Set &pll_secctl %Long 0x00400000;    // Assert TENABLE= 0, TENABLEDIV= 0, TINITZ= 0
  Data.Set &pll_secctl %Long 0x00410000;    // Assert TENABLE= 0, TENABLEDIV= 0, TINITZ= 1
			   
  //Divider setting for PLL2 
  Data.Set &pll_div1 %Long 0x8011;  // 594/18= 33MHz  -> USB (Use AUXCLK from USB PHY Control register)
  Data.Set &pll_div2 %Long 0x8001;  // 594/2= 297mhz  -> ARM926/HDVICP(Internal)
  Data.Set &pll_div4 %Long 0x8005;  // 594/6= 99MHz  -> VOICE
  Data.Set &pll_div5 %Long 0x8007;  // 594/8= 74.25Mhzv-> VENC for HD video
  Data.Set &pll_cmd %Long Data.Long(sd:&pll_cmd)|0x0001;        // Set GOSET

  WAIT 1.s

  Data.Set &pll_ctl %Long Data.Long(sd:&pll_ctl)|0x0001;

  PRINT "[Done]";
RETURN

Setup_DDR2:

  LOCAL &SDREF
  LOCAL &SDCFG1
  LOCAL &DDR_PHY_VTP_IOCTRL
  LOCAL &VBUSMP
  LOCAL &SDTIM0
  LOCAL &SDTIM1
  LOCAL &DDRPHYCTL1

  &SDREF=0x2000000C
  &SDCFG1=0x20000008
  &DDR_PHY_VTP_IOCTRL=0x01C40074
  &VBUSMP=0x20000020
  &SDTIM0=0x20000010
  &SDTIM1=0x20000014
  &DDRPHYCTL1=0x200000e4

  PRINT "Setup DDR2... " ;

  // VTP Caliberation
  //PWR_DWN bit is made '0', to power the VTP module

  Data.Set &DDR_PHY_VTP_IOCTRL %Long Data.Long(sd:&DDR_PHY_VTP_IOCTRL)&0xFFFF9F3F
  Data.Set &DDR_PHY_VTP_IOCTRL %Long Data.Long(sd:&DDR_PHY_VTP_IOCTRL)|0x00002000
   
  WAIT 500.ms

  Data.Set &DDR_PHY_VTP_IOCTRL %Long Data.Long(sd:&DDR_PHY_VTP_IOCTRL)|0x00000080

  // Powerdown VTP as it is locked (bit 6)
  // Set bit VTP_IOPWRDWN bit 14 for DDR input buffers)
  Data.Set &DDR_PHY_VTP_IOCTRL %Long Data.Long(sd:&DDR_PHY_VTP_IOCTRL)|0x00004040; 

  // DDR2 configuration for 243MHz clock
  Data.Set &DDRPHYCTL1 %Long 0x000000c5;  //External DQS gatin enabled

  Data.Set &SDCFG1 %Long 0x0853C832;		
  Data.Set &SDREF %Long 0x00000768;  // Program SDRAM Refresh Control Register
  Data.Set &VBUSMP %Long 0x000000FE;	 // VBUSM Burst Priority Register, pr_old_count= 0xFE
  Data.Set &SDTIM0 %Long 0x3C934B51;  // Program SDRAM Timing Control Register1
  Data.Set &SDTIM1 %Long 0x4221C722;  // Program SDRAM Timing Control Register2
  Data.Set &SDCFG1 %Long 0x08534832;  // Program SDRAM Bank Config Register

  GOSUB psc_change_state 13. 0x1
  GOSUB psc_change_state 13. 0x3

  PRINT "DDR2 init is done for 16-bit Interface ";
  PRINT "[Done]" ;

RETURN


