OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm","elf32-littlearm")
OUTPUT_ARCH(arm)
ENTRY(_start)

/*
    Fascinating:
    If you read the K60 manual in detail, you will find these sentences:

    --- %< ---
       The SRAM is split into two logical arrays that are 32-bits wide.
           SRAM_L - Accessible by the code bus of the Cortex-M4 core and
                    by the backdoor port.
           SRAM_U - Accessible by the system bus of the Cortex-M4 core and
                    by the backdoor port.
    --- %< ---

    After some tests it turns out that this means, that the Instruction Bus of
    the Cortex-M4 can directly read from SRAM_L, at the same time as the
    Data Bus of the Cortex-M4 reads from SRAM_U.
    It DOES NOT work if you swap these memories (instruction fetches to SRM_U,
    data load/stored to/from SRAM_L).

    Putting the code to SRAM_L and putting the data to SRAM_U gives around
    40% more benchmark performance than linking both to just SRAM_U or SRAM_L
    or when you swap the memories.
*/

/*
    Define our own ELF segments.
    This just gives a LOT more control how the ELF file is structured.
*/
PHDRS
{
  mycode   PT_LOAD ;
  mydata   PT_LOAD ;
}

SECTIONS
{
  /************************/
  /** mycode ELF Segment **/
  /************************/
  /* Put code into SRAM_L */
  . = 0x1FFFC000;
  .text :
  {
    *(.text .text.*)
    /* make sure code fits into SRAM_L memory */
    ASSERT ( (. <= 0x1FFFFFF0), "Code does not fit into SRAM_L memory." );
  } :mycode

  /************************/
  /** mydata ELF Segment **/
  /************************/
  /* Put rest (non code) into SRAM_U */
  . =  0x20000000;
  .rodata :
  {
    *(.rodata .rodata.* .gnu.linkonce.r.*)
    *(.rodata1)
  } :mydata

  . = ALIGN(4);

  .data :
  {
     *(.data .data.* .gnu.linkonce.d.* )
     KEEP (*(.gnu.linkonce.d.*personality*))
     *(.sdata .sdata.* .gnu.linkonce.s.*)
  }

  . = ALIGN(4);

  PROVIDE ( _bss_start = . );
  .bss :
  {
     *(.sbss .sbss.* .gnu.linkonce.sb.*)
     *(.scommon)
     *(.bss .bss.* .gnu.linkonce.b.*)
     *(COMMON)
     /* make sure data does not overlap stack area == 0x20003000++0xFFF */
     ASSERT ( (. <= 0x20003000), "Data is too big: It overlaps stack area.");
  }
  PROVIDE ( _bss_end = .);

  . = ALIGN(16);

  PROVIDE ( heap_start = .);

  /* initial stack pointer */
  PROVIDE ( _sp = 0x20003FF0);
}
