; --------------------------------------------------------------------------------
; @Title:  Freescale K70 series TOWER SYSTEM MODULE SPI FLASH Program script
;
; @Description:
; SPI  (N25Q00,Micron) is connected to DSPI2_CE0
; SRAM: 0x20000000
; SPI Base Register Address : 0x400AC000
;
; @Author: jjeong
; @Copyright: (C) 1989-2019 Lauterbach GmbH, licensed for use with TRACE32(R) only
; @Chip: ?K70F*
; @Board: K70F120
; @Keywords: kinetis flash SPI N25Q00
; --------------------------------------------------------------------------------
; $Id: k70f120m-spi.cmm 7605 2019-11-05 16:45:28Z bschroefel $

LOCAL &arg1
ENTRY &arg1
&arg1=STRing.UPpeR("&arg1")  // for example "PREPAREONLY"

&nCS=0.
&DSPIBase=0x400AC000

  RESet
  SYStem.CPU MK70FN1M0VMJ15
  SYStem.JtagClock CTCK 20Mhz
  SYStem.MemAccess DAP
  IF COMBIPROBE()||UTRACE()
  (
    SYStem.CONFIG.CONNECTOR MIPI20T
  )
  SYStem.CONFIG.DEBUGPORTTYPE SWD
  SYStem.Option IMASKASM ON
  SYStem.Option DUALPORT ON
  SYStem.Up

  GOSUB DisableWatchdog

//CCM config
  PER.Set.simple SD:0x40048030 %Long 0x00001100  ;SCGC3 clock enable for NFC, DSPI2
  PER.Set.simple SD:0x40048038 %Long 0x41D82     ;PORTB,PORTC,PORTD clock enable 

  GOSUB IOMUX_SPI_config

//DSPI2_config
Data.Set (&DSPIBase)      %LONG 0x813F3000 ;MCR
Data.Set (&DSPIBase+0xC)  %LONG 0x38232150 ;CTAR0 ,   slower 0x38236153

  GOSUB READ_ID_TEST

  Break.RESet

  FLASHFILE.RESet

; FLASHFILE.CONFIG  <DSPI Base>   <unused> <unused>   <PCS#>
  FLASHFILE.CONFIG  &DSPIBase      0x0      0x0        &nCS

//FLASHFILE.TARGET <Code_range>        <Data_range>          <Algorithm file>
  FLASHFILE.TARGET 0x20000000++0x3FFF  EAHB:0x20004000++0x43FF   ~~/demo/arm/flash/byte/spin25q00_dspi.bin   /keep    /stacksize 0x200 /dualport

  FLASHFILE.GETID

//End of the test prepareonly
IF "&arg1"=="PREPAREONLY"
ENDDO


 ;FLASHFILE.DUMP 0x0                             ; Read SPI 

 ;FLASHFILE.ERASE 0x0--0xFFFFF  /EraseBadBlock   ; Erase SPI

 ;FLASHFILE.LOAD * 0x0                           ; Write SPI

ENDDO

IOMUX_SPI_config:

  PER.Set SD:0x4004C02C %Long 0x200; PTD11, SPI2_PCS0
  PER.Set SD:0x4004C030 %Long 0x200; PTD12, SPI2_SCK
  PER.Set SD:0x4004C034 %Long 0x200; PTD13, SPI2_SOUT
  PER.Set SD:0x4004C038 %Long 0x200; PTD14, SPI2_SIN
  PER.Set SD:0x4004C03C %Long 0x200; PTD15, SPI2_PCS1

RETURN


; --------------------------------------------------------------------------------
; Disable watchdog

DisableWatchdog:
  LOCAL &tmp1 &tmp2
  &tmp1=Data.Long(ST:0x20000000)
  &tmp2=Data.Long(ST:0x20000004)

  ; The watchdog has a restrictive timing. It has to be configured and unlocked within a peripod
  ; of 20+256 cycles. Therefor the unlock sequence need to be done by a small target program.
  Data.Assemble ST:0x20000000  strh r1,[r0]  ;SD:0x4005200E = 0xC520   (Key 1)
  Data.Assemble ,              strh r2,[r0]  ;SD:0x4005200E = 0xD928   (Key 2)
  Data.Assemble ,              strh r4,[r3]  ;SD:0x40052000 = 0x0000   (Config register)
  Data.Assemble ,              bkpt #0
  Register.Set PC 0x20000000
  Register.Set R0 0x4005200E
  Register.Set R1 0xC520
  Register.Set R2 0xD928
  Register.Set R3 0x40052000
  Register.Set R4 0x0
  Go.direct
  WAIT !STATE.RUN()

  Data.Set ST:0x20000000 %Long &tmp1
  Data.Set ST:0x20000004 %Long &tmp2

  RETURN

READ_ID_TEST:
(
  SCREEN.OFF
  GOSUB  SPI_WRITE_BYTE 0x9f
  GOSUB  SPI_WRITE_BYTE 0x00
  GOSUB  SPI_WRITE_BYTE 0x00
  GOSUB  SPI_WRITE_BYTE 0x00
  GOSUB  SPI_CS_HIGH
  SCREEN.ON
  RETURN
)

SPI_WRITE_BYTE:
(
  ENTRY &byte

  Data.Set &DSPIBase+0x34 %Long 0x80000000|(0x10000<<&nCS)|&byte
  PRINT  "read(&byte) : 0x" Data.Long(A:&DSPIBase+0x38)
  RETURN
)

SPI_CS_HIGH:
(
  &temp=Data.Long(A:(&DSPIBase+0x34))
  Data.Set &DSPIBase+0x34 %Long &temp&(~(0x80000000|(0x10000<<&nCS))|0x00)
  PRINT  "read(cs_high) : 0x" Data.Long(A:&DSPIBase+0x38)

  RETURN
)