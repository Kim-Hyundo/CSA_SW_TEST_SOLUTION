; --------------------------------------------------------------------------------
; @Title: Linux Demo for TRACE32 OS Awareness for the DIMM-MX53 Board
; @Description:
;   The example is generated for the emtrion DIMM-MX53 board using an ICD.
;   It will NOT run on any other board, but may be used as a template
;   for others.
;   Linux is downloaded to the board via ICD.
; @Keywords: awareness, i.mx53
; @Author: DIE
; @Board: DIMM-MX53
; @Chip: IMX53?
; @Copyright: (C) 1989-2019 Lauterbach GmbH, licensed for use with TRACE32(R) only
; --------------------------------------------------------------------------------
; $Id: mx53_linux.cmm 15223 2019-11-05 16:29:45Z bschroefel $


; Starting Linux example with TRACE32:
; - Connect NULL modem cable to UART (J14)
;   - 115200 baud, 8/N/1, no(!) handshake
; - Start TRACE32
; - Switch on the board
; - TRACE32: "do mx53_linux"
; - Terminal: start "hello"

LOCAL &ka_path &awareness

 SCREEN.ALways      ; permanent update for internal terminal window
 ; screen.on        ; if you use external terminal


; Debugger Reset

 WinPAGE.RESet
 AREA.RESet
 WinPOS 0. 21. 70. 9. 0. 0. W000
 AREA.view

 PRINT "resetting..."

 RESet


; Open serial terminal window on COM1

 DO ~~/demo/etc/terminal/serial/term.cmm COM1 115200.


; Initializing Debugger

 PRINT "initializing..."
 SYStem.CPU iMX53
 SYStem.JtagClock 20.MHz

 SYStem.Option ResBreak OFF     ; hardware dependent, see documentation
 SYStem.Option DACR ON          ; give Debugger global write permissions
 TrOnchip.Set DABORT OFF        ; used by Linux for page miss!
 TrOnchip.Set PABORT OFF        ; used by Linux for page miss!
 TrOnchip.Set UNDEF OFF         ; my be used by Linux for FPU detection
 SYStem.Option MMUSPACES ON     ; enable space ids to virtual addresses

 IF ETM()
   ETM.OFF                      ; do not touch ETM registers

 SYStem.Up                      ; resets target and starts on-board bootloader

 SETUP.IMASKASM ON              ; lock interrupts while single stepping


; Open a Code Window -- we like to see something

 WinPOS 0. 0. 75. 20.
 List.auto
 SCREEN.display


; Target Setup

 ; let the bootloader initialize the board
 WinTOP TERM.view                            ; set terminal window to front
 Go.direct                                     ; start u-boot
 PRINT "target setup..."
 WAIT 2.s
 TERM.Out 0x20                          ; stop autoboot
 WAIT 1.s
 Break.direct


; Load the Linux kernel image

 ; Use the next lines only to load the Linux image into
 ; RAM using the debugger.

 PRINT "loading Linux kernel image..."
 Data.LOAD.Binary uImage-dimm-mx53 0x70800000


; Loading initial ram disk (initrd)

 ; Use the next lines only, if you want to use an initrd,
 ; and if you want to download this with the debugger.

 ; The load address is passed by a command line option

 PRINT "loading initial ram disk..."
 Data.LOAD.Binary ramdisk.image.gz 0x71000000 /NoClear /NosYmbol
 ;Data.LOAD.Binary rootfs.ext2.gz 0x71000000 /noclear /nosymbol


; Load the Linux kernel symbols into the debugger

 PRINT "loading Linux kernel symbols..."
 Data.LOAD.Elf vmlinux /NoCODE


; Start Linux via U-Boot

 Break.Set start_kernel /Onchip
 Go.direct
 PRINT "starting Linux..."
 ; set boot arguments
 TERM.Out "setenv bootargs console=ttymxc0,115200 root=/dev/ram rw initrd=0x71000000,6M " 0xa
 ; boot Linux from memory: bootm <kernel>
 TERM.Out "bootm 0x70800000" 0x0a


; Declare the MMU format to the debugger
 ; - table format is "LINUX"
 ; - table base address is at label "swapper_pg_dir"
 ; - kernel address translation
 ; Map the virtual kernel symbols to physical addresses to give
 ; the debugger access to it before CPU MMU is initialized

 PRINT "initializing debugger MMU..."
 MMU.FORMAT LINUX swapper_pg_dir 0x80000000--0x99ffffff 0x70000000
 TRANSlation.COMMON 0x7f000000--0xffffffff              ; common area for kernel and processes
 TRANSlation.TableWalk ON   ; debugger uses a table walk to decode virtual addresses
 TRANSlation.ON             ; switch on debugger(!) address translation

 WAIT !STATE.RUN()

; Initialize Linux Support

 ; Note that the Linux awareness needs the kernel symbols to work

 ; check linux major version
 IF STRing.SCAN(Data.STRing(linux_banner), "Linux version 2.", 0)==0
 (
     &ka_path="~~/demo/arm/kernel/linux/linux-2.x"
     &awareness="linux.t32"
 )
 ELSE
 (
     &ka_path="~~/demo/arm/kernel/linux/linux-3.x"
     &awareness="linux3.t32"
 )

 PRINT "initializing RTOS support..."
 TASK.CONFIG &ka_path/&awareness               ; loads Linux awareness
 MENU.ReProgram &ka_path/linux            ; loads Linux menu

 ; Group kernel area to be displayed with red bar
 GROUP.Create "kernel" 0x80000000--0xffffffff /RED


; Ok, we're done, let's continue

 Go.direct
 PRINT "still starting Linux... (please wait)"
 WAIT 5.s

 PRINT "done."     ; done with loading and starting NetBSD

 Break.direct


; --------------------------------------------------------------------------------
; Application Debugging
; e.g. "hello"
; --------------------------------------------------------------------------------

 PRINT "please start ""hello"" in terminal"

 ; specify path to "hello" symbol file,
 ; this allows the debugger to find it automatically
 sYmbol.SourcePATH.Set examples

 ; run skript to start debugging from main()
   LOCAL &extdir
   &extdir=TASK.GETDIR()
   DO &extdir/app_debug hello

 ENDDO

