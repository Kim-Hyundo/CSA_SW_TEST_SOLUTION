; --------------------------------------------------------------------------------
; @Title: Linux Demo for TRACE32 OS Awareness on the i.MX27ADS board
; @Description: 
;   The example is generated for the Freescale i.MX27ADS board using an ICD.
;   It will NOT run on any other board, but may be used as a template
;   for others.
;   Linux is downloaded to the board via ICD.
; @Keywords: awareness, freescale, imx27*, Linux, RTOS
; @Author: KJM
; @Board: i.MX27ADS
; @Chip: IMX27
; @Copyright: (C) 1989-2019 Lauterbach GmbH, licensed for use with TRACE32(R) only
; --------------------------------------------------------------------------------
; $Id: imx27ads_linux.cmm 15210 2019-11-04 10:51:00Z bschroefel $


; PLEASE NOTE: Add "jtag=on" to the command line parameters, to prevent
;              Linux from goint into wait mode (which spoils JTAG).

; Starting Linux example with TRACE32 and terminal:
; - Connect STRAIGHT modem cable to UARTC (upper connector next to Ethernet)
; - Start TRACE32
; - Open console terminal: 115200 baud, 8/N/1, no(!) handshake
; - Switch on the board
; - (T32) "do linux"


 LOCAL &ka_path &awareness

 SCREEN.ON

; Debugger Reset

 WinPAGE.RESet
 AREA.RESet
 WinPOS 0. 26. 75. 8. 0. 0. W000
 AREA.view
 
 PRINT "resetting..."
 
 RESet

; Initializing Debugger
 
 PRINT "initializing..."
 SYStem.CPU MCIMX27             ; set your CPU here
 SYStem.Option DACR ON          ; give Debugger global write permissions
 SYStem.Option ResBreak OFF     ; board specific, see documentation
 SYStem.JtagClock 10.0MHz       ; board specific, see documentation
 TrOnchip.Set DABORT OFF        ; used by Linux for page miss!
 TrOnchip.Set PABORT OFF        ; used by Linux for page miss!
 TrOnchip.Set UNDEF OFF         ; my be used by Linux for FPU detection
 SYStem.Option MMUSPACES ON     ; enable space ids to virtual addresses
 
 ETM.ON
 ETM.PortDisableOnchip ON
 Trace.METHOD Onchip

 SYStem.Up

 SETUP.IMASKASM OFF              ; lock interrupts while single stepping
 SETUP.IMASKHLL OFF              ; lock interrupts while single stepping
 
 
 DO ~~/demo/etc/terminal/serial/term.cmm COM1 115200.
 

; Target Setup: initialize board memory access and peripherals
 PRINT "target setup..."

 ; Either let the boot monitor setup the board
    ; go
    ; wait 1.s
    ; break
 ; or use the debugger to initialize it
    DO imx27ads_init


; Load the Linux kernel

 ; If you are using a flashed kernel, or if you're loading 
 ; your kernel via TFTP, use the boot monitor to do so.
 
 ; Use the next lines (loading the kernel, setting registers
 ; and boot parameters) only to load the kernel into
 ; RAM using the debugger.

 ; vmlinux starts physically at RAM start + 0x8000 
 ; We have to adjust it from the virtual start address 
 ; to the physical start address
 ; i.e.: Data.LOAD.Elf vmlinux <physical start>-<virtual start>

 PRINT "loading Linux kernel..."
 Data.LOAD.Elf vmlinux 0xA0008000-0xC0008000 /NosYmbol

 Register.RESet

 ; Set PC on start address of image
 Register.Set PC 0xA0008000
 
 ; Set machine type in R1; see arch/arm/tools/mach-types
 Register.Set R1 0x034E    ; i.MX27ADS board
 
 ; Set boot parameter tags for linux boot
 DO imx27ads_atag_list


; Loading initial ram disk (initrd)

 ; Use the next lines only, if you want to use an initrd,
 ; and if you want to download this with the debugger.

 ; Load ram file system image into ram disk
 ; The load address is either hardcoded in arch/arm/<board>/arch.c,
 ; or must be passed by a boot parameter, or as command line option
 
 ;print "loading ramdisk..."
 ;Data.LOAD.Binary ramdisk.image.gz 0x80800000 /noclear /nosymbol
 ;Data.LOAD.Binary rootfs.ext2.gz 0x80800000 /noclear /nosymbol
 

; Load the Linux kernel symbols into the debugger
 ; use /strippart and /path to map source paths, if necessary

 PRINT "loading Linux kernel symbols..."
 Data.LOAD.Elf vmlinux /NoCODE

; Open a Code Window -- we like to see something

 WinPOS 0. 0. 75. 20.
 List.auto
 SCREEN.display
 

; Declare the MMU format to the debugger
 ; - table format is "LINUX"
 ; - table base address is at label "swapper_pg_dir"
 ; - kernel address translation
 ; Map the virtual kernel symbols to physical addresses to give 
 ; the debugger access to it before CPU MMU is initialized

 PRINT "initializing debugger MMU..."
 MMU.FORMAT LINUX swapper_pg_dir 0xc0000000--0xc7ffffff 0xA0000000
 TRANSlation.COMMON 0xbf000000--0xffffffff            ; common area for kernel and processes
 TRANSlation.TableWalk ON   ; debugger uses a table walk to decode virtual addresses
 TRANSlation.ON             ; switch on debugger(!) address translation 
 

; Initialize Linux Awareness

 ; Note that the Linux awareness needs the kernel symbols to work
 
 ; check linux major version
 IF STRing.SCAN(Data.STRing(linux_banner), "Linux version 2.", 0)==0
 (
     &ka_path="~~/demo/arm/kernel/linux/linux-2.x"
     &awareness="linux.t32"
 )
 ELSE
 (
     &ka_path="~~/demo/arm/kernel/linux/linux-3.x"
     &awareness="linux3.t32"  
 )
 
 PRINT "initializing RTOS support..."
 TASK.CONFIG &ka_path/&awareness               ; loads Linux awareness 
 MENU.ReProgram &ka_path/linux            ; loads Linux menu 

 
 
 ; Group kernel area to be displayed with red bar
 GROUP.Create "kernel" 0xc0000000--0xffffffff /RED

; Ok, we're done, let's start Linux
 
 Go
 PRINT "starting Linux... (please wait)"
 WAIT 8.s
 Break
 
 PRINT "done."     ; done with loading and starting Linux

 ENDDO




