; -------------------------------------------------------------------------------
; @Title: Target settings & Flash Download CMM
; Script arguments:
;
;   DO tc277.cmm
;
; --------------------------------------------------------------------------------

ENTRY &elfPath &Core
LOCAL &elfFilePath &Core_name

&elfFilePath=&elfPath
&Core_name=&Core

LOCAL &parameters &param_prepareonly &param_checkbmhd &param_cpu &param_dualport
ENTRY %LINE &parameters

&param_prepareonly=(STRing.SCAN(STRing.UPpeR("&parameters"),"PREPAREONLY",0)!=-1)
&param_checkbmhd=(STRing.SCAN(STRing.UPpeR("&parameters"),"CHECKBMHD",0)!=-1)
&param_cpu=STRing.SCANAndExtract(STRing.UPpeR("&parameters"),"CPU=","")
&param_dualport=0
IF VERSION.BUILD.BASE()>=48610.
  &param_dualport=STRing.SCANAndExtract(STRing.UPpeR("&parameters"),"DUALPORT=","0")

; ------------------------------------------------------------------------------
; Initialize
IF SYStem.MODE()<5.
(
  SYStem.RESet

  IF "&param_cpu"!=""
    SYStem.CPU &param_cpu
  IF !CPUIS(TC27*)
    ;SYStem.CPU TC277TF
    System.CPU.DETECT

  CORE.select 0.        ; CPU0 is selected for flash programming.

  IF !Simulator()
  (
	  IF CPUIS("TC27*A")||CPUIS("TC27*E")||CPUIS("TC27*F")
	  (
		; Emulation Devices in LQFP packages (except Fusion Quad and A-Step)
		; do not support JTAG (TDI pin is used as VDDPSB)
		IF (ID.CABLE()==0x0029)||(ID.CABLE()==0x4155||(ID.CABLE()==0x4150))
		(
		  ; DAP only supported by
		  ; - Bi-directional OCDS Debug Cable (0x0029)
		  ; - Debug Cable Automotive (0x4155)
		  ; - Debug Cable Automotive PRO (0x4150)
		  SYStem.CONFIG.DEBUGPORTTYPE DAP2
		)
		ELSE
		(
		  DIALOG.OK CPU()+" not supported by debug cable."
		  ENDDO
		)
	  )
  
  )
  SYStem.Up
)

IF Simulator()
(
	Data.Load.ELF "&elfFilePath"
	
	PRINT "SIMULATOR FLASHDOWNLOAD COMPLETE"
	ENDDO
)

else
(

	IF &param_checkbmhd
	(
	  LOCAL &validBmhdFound
	  GOSUB CheckAllBootModeHeaders
	  ENTRY &validBmhdFound
	  IF &validBmhdFound
		ENDDO BMHD_OK
	  ENDDO BMHD_MISSING
	)

	; Disable Watchdog Timers on TC27xT[E]

	; Disable the Safety Watchdog Timer (overall system level watchdog):
	PER.Set.simple D:0xF00360F4 %Long 0x00000008 // SCU_WDTSCON1, Request to disable the WDT
	; Disable the CPU Watchdog Timers:
	PER.Set.simple D:0xF0036104 %Long 0x00000008 // SCU_WDTCPU0CON1, Request to disable the WDT
	PER.Set.simple D:0xF0036110 %Long 0x00000008 // SCU_WDTCPU1CON1, Request to disable the WDT
	PER.Set.simple D:0xF003611C %Long 0x00000008 // SCU_WDTCPU2CON1, Request to disable the WDT

	; ------------------------------------------------------------------------------
	; Flash Declaration

	IF VERSION.BUILD()<38225.
	(
	  DIALOG.OK "Please request a TRACE32 software update to support Boot Mode Header handling (btmtc-support@lauterbach.com)"
	  ENDDO
	)

	; Detect EEPROM sector size depending on SCU_CHIPID.UCODE (uCode revision)
	LOCAL &eesecsize
	IF ((Data.Long(D:0xF0036140)>>17.)&0x7F)!=0
	  &eesecsize=0x2000  ; uCode >= 2:  8 kByte sector size for TC27x AB-step and later
	ELSE
	  &eesecsize=0x10000 ; uCode == 0: 64 kByte sector size for TC27x AA-step

	; Reset flash configuration
	FLASH.RESet

	; Program flash PF0
	FLASH.Create  1. 0xA0000000--0xA000BFFF  0x4000 TARGET Long /BootModeHeaDer 0xA0000000--0xA000001F  ; PS0, S0..S2
	FLASH.Create  1. 0xA000C000--0xA0013FFF  0x4000 TARGET Long /BootModeHeaDer 0xA000FFE0--0xA000FFFF  ; PS0, S3..S4
	FLASH.Create  1. 0xA0014000--0xA0017FFF  0x4000 NOP    Long   ; PS0, S5 (Tuning Protection)
	FLASH.Create  1. 0xA0018000--0xA001BFFF  0x4000 NOP    Long   ; PS0, S6 (HSM)
	FLASH.Create  1. 0xA001C000--0xA001FFFF  0x4000 TARGET Long /BootModeHeaDer 0xA001FFE0--0xA001FFFF  ; PS0, S7
	FLASH.Create  1. 0xA0020000--0xA005FFFF  0x8000 TARGET Long /BootModeHeaDer 0xA0020000--0xA002001F  ; PS0, S8..S15
	FLASH.Create  1. 0xA0060000--0xA007FFFF 0x10000 NOP    Long   ; PS0, S16..S17 (HSM)
	FLASH.Create  2. 0xA0080000--0xA009FFFF 0x10000 TARGET Long   ; PS1, S18..S19
	FLASH.Create  2. 0xA00A0000--0xA00FFFFF 0x20000 TARGET Long   ; PS1, S20..S22
	FLASH.Create  3. 0xA0100000--0xA017FFFF 0x40000 TARGET Long   ; PS2, S23..S24
	FLASH.Create  4. 0xA0180000--0xA01FFFFF 0x40000 TARGET Long   ; PS3, S25..S26
	; Program flash PF1
	FLASH.Create  5. 0xA0200000--0xA021FFFF  0x4000 TARGET Long   ; PS0, S0..S7
	FLASH.Create  5. 0xA0220000--0xA025FFFF  0x8000 TARGET Long   ; PS0, S8..S15
	FLASH.Create  5. 0xA0260000--0xA027FFFF 0x10000 TARGET Long   ; PS0, S16..S17
	FLASH.Create  6. 0xA0280000--0xA029FFFF 0x10000 TARGET Long   ; PS1, S18..S19
	FLASH.Create  6. 0xA02A0000--0xA02FFFFF 0x20000 TARGET Long   ; PS1, S20..S22
	FLASH.Create  7. 0xA0300000--0xA037FFFF 0x40000 TARGET Long   ; PS2, S23..S24
	FLASH.Create  8. 0xA0380000--0xA03FFFFF 0x40000 TARGET Long   ; PS3, S25..S26
	; Data flash DF0
	FLASH.Create  9. 0xAF000000--0xAF05FFFF &eesecsize TARGET Long   ; DF0, DF_EEPROM0..DF_EEPROM47
	; Data flash DF1
	FLASH.Create 10. 0xAF100000--0xAF1003FF   0x400 NOP    Long   ; DF1, UCB0 = UCB_PFlash
	FLASH.Create 10. 0xAF100400--0xAF1007FF   0x400 NOP    Long   ; DF1, UCB1 = UCB_DFlash
	FLASH.Create 10. 0xAF100800--0xAF100BFF   0x400 NOP    Long   ; DF1, UCB2 = UCB_HSMCOTP
	FLASH.Create 10. 0xAF100C00--0xAF100FFF   0x400 NOP    Long   ; DF1, UCB3 = UCB_OTP
	FLASH.Create 10. 0xAF101000--0xAF1013FF   0x400 NOP    Long   ; DF1, UCB4 = UCB_IFX
	FLASH.Create 10. 0xAF101400--0xAF1017FF   0x400 NOP    Long   ; DF1, UCB5 = UCB_DBG
	FLASH.Create 10. 0xAF101800--0xAF101BFF   0x400 NOP    Long   ; DF1, UCB6 = UCB_HSM
	FLASH.Create 10. 0xAF101C00--0xAF101FFF   0x400 NOP    Long   ; DF1, UCB7 = UCB_HSMCFG
	FLASH.Create 10. 0xAF102000--0xAF102FFF   0x400 NOP    Long   ; DF1, UCB8..UCB11
	FLASH.Create 10. 0xAF103000--0xAF103FFF   0x400 NOP    Long   ; DF1, UCB12..UCB15 = Erase Counter
	FLASH.Create 11. 0xAF110000--0xAF11FFFF  0x2000 NOP    Long   ; DF1, HSM0..HSM7

	; Cached program flash address range
	FLASH.CreateALIAS 0x80000000--0x80FFFFFF 0xA0000000
	; HSM private access to DF1
	FLASH.CreateALIAS 0xFF110000--0xFF11FFFF 0xAF110000

	IF &param_dualport==0
	  FLASH.TARGET 0xC0000000 0xD0000000 0x4000 tc2.bin
	ELSE
	  FLASH.TARGET 0xC0000000 0xD0000000 0x4000 tc2.bin /DualPort

	; Flash script ends here if called with parameter PREPAREONLY
	IF &param_prepareonly
	  ENDDO PREPAREDONE

	; ------------------------------------------------------------------------------
	; Example for download



	; Enable flash programming
	FLASH.ReProgram.ALL

	Data.LOAD.auto "&elfFilePath"

	; Use the following commands to manually program a valid default BMHD (see comment above)
	; Data.Set 0xA0000000++0x17 %Long 0xA0000020 0xB3590070 0x00000000 0x00000000 0x00000000 0x00000000
	; Data.SUM 0xA0000000++0x17 /Long /ByteSWAP /CRC32
	; Data.Set 0xA0000018 %Long Data.SUM()
	; Data.Set 0xA000001C %Long ~Data.SUM()

	GOSUB CheckAllBootModeHeaders
	ENTRY &progflash
	IF !&progflash
	(
	  DIALOG.YESNO "No valid Boot Mode Header found!" \
				   "Flashing now can lock your device." \
				   "Do you really want to program flash?"
	  ENTRY &progflash
	)

	IF &progflash
	(
	  ; Finally program flash memory
	  FLASH.ReProgram.off
	)
	ELSE
	(
	  ; Revert loaded data
	  IF VERSION.BUILD()>=51257.
		FLASH.ReProgram.CANCEL
	  ELSE
	  (
		FLASH.ReProgram.ALL
		FLASH.ReProgram.off
	  )
	)

)
  PRINT "TEST SCRIPT"
  MCDS.TimeStamp ON
  CLOCK.ON
  MCDS.SOURCE.SET CPUMux0.Program ON
  MCDS.SOURCE.SET CPUMux0.ReadAddr ON
  MCDS.SOURCE.SET CPUMux0.WriteAddr ON
  MCDS.SOURCE.SET CPUMux0.WriteData ON
  
  IF "&Core_name"=="0"
	MCDS.SOURCE.SET CPUMux0.Core TriCore0
  ELSE IF "&Core_name"=="1"
    MCDS.SOURCE.SET CPUMux0.Core TriCore1
  ELSE IF "&Core_name"=="2"
    MCDS.SOURCE.SET CPUMux0.Core TriCore2
  Trace.Init
  PRINT "POWERVIEW FLASHDOWNLOAD COMPLETE"
ENDDO

; --------------------------------------------------------------------------------
; Check if at least one valid boot mode header is available
;
CheckAllBootModeHeaders:
(
  LOCAL &bmhdValid
  GOSUB CheckBootModeHeader 0xA0000000
  ENTRY &bmhdValid
  IF &bmhdValid
    RETURN &bmhdValid
  GOSUB CheckBootModeHeader 0xA0020000
  ENTRY &bmhdValid
  IF &bmhdValid
    RETURN &bmhdValid
  GOSUB CheckBootModeHeader 0xA000FFE0
  ENTRY &bmhdValid
  IF &bmhdValid
    RETURN &bmhdValid
  GOSUB CheckBootModeHeader 0xA001FFE0
  ENTRY &bmhdValid
  RETURN &bmhdValid
)

; --------------------------------------------------------------------------------
; Check if Boot Mode Header has valid contents
;
CheckBootModeHeader:
(
  LOCAL &addr &result &bmhdid
  ENTRY &addr
  &result=TRUE()

  ON.ERROR GOSUB
  (
    &result=FALSE()
    RETURN
  )

  IF !STRing.FIND("&addr",":")
    &addr="C:&addr"

  ; Check Boot Mode Header ID
  &bmhdid=Data.Word(&addr+0x6)
  IF &result
  (
    IF &bmhdid!=0xB359
      &result=FALSE()
  )

  ; Check Boot Mode Header CRC
  IF &result
  (
    Data.SUM &addr++0x17 /Long /ByteSWAP /CRC32
    IF &result
    (
      Data.Set &addr+0x18 %Long Data.SUM() /DIFF
      IF &result
      (
        &result=!FOUND()
        IF &result
        (
          Data.Set &addr+0x1C %Long ~Data.SUM() /DIFF
          IF &result
          (
            &result=!FOUND()
          )
        )
      )
    )
  )

  RETURN &result
)
